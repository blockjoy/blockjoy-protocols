name: Build Docker Images

on:
  pull_request:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/**'
      - '!.github/workflows/**'
    types:
      - opened      # PR is created
      - synchronize # New commits pushed
      - reopened    # Closed PR is reopened
  pull_request_target:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
      - '.github/**'
      - '!.github/workflows/**'
    types:
      - closed  # PR is merged or closed

permissions:
  contents: read
  packages: write
  id-token: write
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  detect-changes:
    runs-on: dev
    if: |
      github.event_name == 'pull_request' && 
      github.event.pull_request.user.login != 'renovate[bot]' && 
      github.event.action != 'closed'
    outputs:
      base_matrix: ${{ steps.set-matrix.outputs.base_matrix }}
      clients_matrix: ${{ steps.set-matrix.outputs.clients_matrix }}
      protocols_matrix: ${{ steps.set-matrix.outputs.protocols_matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 0  # Fetch all history for all tags and branches

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@d6e91a2266cdb9d62096cebf1e8546899c6aa18f # v45
        with:
          since_last_remote_commit: true
          fetch_depth: 0
          files: |
            **
            !**/babel.yaml

      - name: List all changed files
        env:
          ALL_CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        run: |
          for file in ${ALL_CHANGED_FILES}; do
            echo "$file was changed"
          done
          
      - name: Debug changed files outputs
        env:
          ALL_CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        run: |
          echo "Debug outputs from changed-files action:"
          echo "Changed files:"
          echo "$ALL_CHANGED_FILES"
          
      - name: Generate build matrices
        id: set-matrix
        env:
          ALL_CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        run: |
          # First find all Docker build contexts (directories containing Dockerfile)
          DOCKER_DIRS=$(find . -name Dockerfile -exec dirname {} \; | sed 's|^./||' | sort)
          echo "Found Docker directories:"
          echo "$DOCKER_DIRS"
          
          echo "Changed files in this commit:"
          echo "$ALL_CHANGED_FILES"
          
          # For each changed file, find which Docker directory it belongs to
          CHANGED_DIRS=$(for file in ${ALL_CHANGED_FILES}; do
            echo "Checking file: $file"
            echo "$DOCKER_DIRS" | while read -r docker_dir; do
              if [[ "$file" =~ ^"$docker_dir"(/|$) ]]; then
                echo "$docker_dir"
              fi
            done
          done | sort -u)
          echo "Changed directories:"
          echo "$CHANGED_DIRS"
          
          # Create matrices using jq, filtering by directory structure
          BASE=$(echo "$CHANGED_DIRS" | grep "^node-base$" || true)
          CLIENTS=$(echo "$CHANGED_DIRS" | grep "^clients/" || true)
          PROTOCOLS=$(echo "$CHANGED_DIRS" | grep "^protocols/[^/]\+/[^/]\+$" || true)
          
          echo "Base dirs: $BASE"
          echo "Client dirs: $CLIENTS"
          echo "Protocol dirs: $PROTOCOLS"
          
          # Only output matrices if we have changes
          if [[ -n "$BASE" ]]; then
            echo "base_matrix=$(echo "$BASE" | jq -Rsc 'split("\n")[:-1] | {include: map({image_path: .})}')" >> $GITHUB_OUTPUT
          else
            echo 'base_matrix={"include":[]}' >> $GITHUB_OUTPUT
          fi
          
          if [[ -n "$CLIENTS" ]]; then
            echo "clients_matrix=$(echo "$CLIENTS" | jq -Rsc 'split("\n")[:-1] | {include: map({image_path: .})}')" >> $GITHUB_OUTPUT
          else
            echo 'clients_matrix={"include":[]}' >> $GITHUB_OUTPUT
          fi
          
          if [[ -n "$PROTOCOLS" ]]; then
            echo "protocols_matrix=$(echo "$PROTOCOLS" | jq -Rsc 'split("\n")[:-1] | {include: map({image_path: .})}')" >> $GITHUB_OUTPUT
          else
            echo 'protocols_matrix={"include":[]}' >> $GITHUB_OUTPUT
          fi

  build-base:
    needs: detect-changes
    if: ${{ fromJson(needs.detect-changes.outputs.base_matrix).include[0] }}
    runs-on: self-hosted
    permissions:
      contents: read      # Allows reading repository contents
      packages: write     # Allows pushing/pulling container images
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.base_matrix) }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Generate version
        id: version
        run: |
          SHA=$(git rev-parse --short HEAD)
          DATE=$(date '+%Y%m%d')
          IMAGE_NAME=$(basename "${{ matrix.image_path }}")
          
          # Try to get the current build number, default to 0 if API call fails
          OUTPUT=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/blockjoy/packages/container/${IMAGE_NAME}/versions" 2>&1)
          API_STATUS=$?
          
          if echo "$OUTPUT" | grep -q "message.*Package not found" || \
             echo "$OUTPUT" | grep -q "status.*404" || \
             [ $API_STATUS -ne 0 ]; then
            echo "Package not found or API error detected"
            echo "Setting build number to 0"
            BUILD_NUM=0
          else
            echo "API call succeeded, parsing response"
            LATEST_BUILD=$(echo "$OUTPUT" | \
              jq "[.[] | select(.metadata.container.tags[] | startswith(\"v${DATE}\"))] | length")
            if [ -z "$LATEST_BUILD" ] || [ "$LATEST_BUILD" = "null" ]; then
              echo "No existing versions found for today, starting at 0"
              BUILD_NUM=0
            else
              echo "Found $LATEST_BUILD existing versions today"
              BUILD_NUM=$((LATEST_BUILD + 1))
            fi
          fi
          
          echo "Debug: Final build number: ${BUILD_NUM}"
          
          # Format: v20250108.1, v20250108.2, etc
          VERSION_TAG="v${DATE}.${BUILD_NUM}"
          
          # Make sure we have a build number before continuing
          if [ -z "$BUILD_NUM" ]; then
            echo "Error: Build number is empty, defaulting to 0"
            BUILD_NUM=0
            VERSION_TAG="v${DATE}.${BUILD_NUM}"
          fi
          
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${SHA}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          
          # Script should succeed even if API call failed
          exit 0
      - name: Generate build contexts
        id: build-contexts
        run: |
          # First, find all directories containing Dockerfiles to build our valid image list
          VALID_IMAGES=$(find . -name Dockerfile -exec dirname {} \; | while read dir; do
            # Convert directory path to image name (e.g., ./ethereum/ethereum-erigon -> ethereum-erigon)
            basename "$dir" | tr '[:upper:]' '[:lower:]'
            # For protocol directories, also add the protocol-client format
            if [[ "$dir" =~ ^./[^/]+/[^/]+ ]]; then
              echo "$dir" | sed 's|^./\([^/]\+\)/\([^/]\+\)|\1-\2|' | tr '[:upper:]' '[:lower:]'
            fi
          done | sort -u)

          # Now extract FROM directives and filter against our valid images
          BUILD_CONTEXTS=$(grep -h "^FROM.*\${.*_IMAGE}" ./${{ matrix.image_path }}/Dockerfile | while read -r line; do
            # Extract variable name from FROM line
            var_name=$(echo "$line" | grep -o '\${[^}]*}' | tr -d '${}\n')
            # Extract image name and remove any default tag
            image=$(grep "^ARG ${var_name}=" ./${{ matrix.image_path }}/Dockerfile | cut -d'=' -f2 | cut -d':' -f1)
            # Check if this image is in our valid image list
            if echo "$VALID_IMAGES" | grep -q "^${image}$"; then
              # Use short name for context key but specify it as a docker-image context with SHA tag
              echo "${image}=docker-image://ghcr.io/blockjoy/${image}:${{ steps.version.outputs.sha }}"
            fi
          done | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "contexts=${BUILD_CONTEXTS}" >> $GITHUB_OUTPUT
          echo "Generated build contexts: ${BUILD_CONTEXTS}"
          echo "Valid images: ${VALID_IMAGES}"
          echo "Current image path: '${{ matrix.image_path }}'"
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@6524bf65af31da8d45b59e8c27de4bd072b392f5 # v3
        with:
          buildkitd-flags: |
            --debug
            --allow-insecure-entitlement network.host
      - name: Build and push base image
        uses: docker/build-push-action@b32b51a8eda65d6793cd0494a773d4f6bcef32dc # v6
        with:
          context: ./${{ matrix.image_path }}
          push: true
          build-args: |
            GRAFANA_LOKI_API_KEY=${{ secrets.GRAFANA_LOKI_API_KEY }}
            GRAFANA_PROM_API_KEY=${{ secrets.GRAFANA_PROM_API_KEY }}
          build-contexts: ${{ steps.build-contexts.outputs.contexts }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:${{ steps.version.outputs.image_tag }}
            ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:${{ steps.version.outputs.version_tag }}

  build-clients:
    needs: [detect-changes]
    if: fromJson(needs.detect-changes.outputs.clients_matrix).include[0]
    runs-on: self-hosted
    permissions:
      contents: read      # Allows reading repository contents
      packages: write     # Allows pushing/pulling container images
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.clients_matrix) }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Generate version
        id: version
        run: |
          set -x  # Enable debug mode to see commands being executed
          set +e
          SHA=$(git rev-parse --short HEAD)
          DATE=$(date '+%Y%m%d')
          CLIENT_NAME=$(basename ${{ matrix.image_path }})
          IMAGE_NAME="${CLIENT_NAME}"
          
          echo "Debug: matrix.image_path = ${{ matrix.image_path }}"
          echo "Debug: IMAGE_NAME = ${IMAGE_NAME}"
          
          # Try to get the current build number, default to 0 if API call fails
          echo "Debug: Querying GitHub API for package ${IMAGE_NAME}"
          
          OUTPUT=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/blockjoy/packages/container/${IMAGE_NAME}/versions" 2>&1)
          API_STATUS=$?
          
          echo "Debug: Full command output:"
          echo "$OUTPUT"
          echo "Debug: API Status: $API_STATUS"
          echo "Debug: Checking if output contains error message..."
          
          # More detailed error checking
          if echo "$OUTPUT" | grep -q "message.*Package not found" || \
             echo "$OUTPUT" | grep -q "status.*404" || \
             [ $API_STATUS -ne 0 ]; then
            echo "Package not found or API error detected"
            echo "Setting build number to 1"
            BUILD_NUM=1
          else
            echo "API call succeeded, parsing response"
            LATEST_BUILD=$(echo "$OUTPUT" | \
              jq "[.[] | select(.metadata.container.tags[] | startswith(\"v${DATE}\"))] | length")
            if [ -z "$LATEST_BUILD" ] || [ "$LATEST_BUILD" = "null" ]; then
              echo "No existing versions found for today, starting at 1"
              BUILD_NUM=1
            else
              echo "Found $LATEST_BUILD existing versions today"
              BUILD_NUM=$((LATEST_BUILD + 1))
            fi
          fi
          
          echo "Debug: Final build number: ${BUILD_NUM}"
          
          # Format: v20250108.1, v20250108.2, etc
          VERSION_TAG="v${DATE}.${BUILD_NUM}"
          
          echo "Debug: Version tag: ${VERSION_TAG}"
          
          # Make sure we have a build number before continuing
          if [ -z "$BUILD_NUM" ]; then
            echo "Error: Build number is empty, defaulting to 1"
            BUILD_NUM=1
            VERSION_TAG="v${DATE}.${BUILD_NUM}"
          fi
          
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${SHA}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
      - name: Generate build contexts
        id: build-contexts
        run: |
          # First, find all directories containing Dockerfiles to build our valid image list
          VALID_IMAGES=$(find . -name Dockerfile -exec dirname {} \; | while read dir; do
            # Convert directory path to image name (e.g., ./ethereum/ethereum-erigon -> ethereum-erigon)
            basename "$dir" | tr '[:upper:]' '[:lower:]'
            # For protocol directories, also add the protocol-client format
            if [[ "$dir" =~ ^./[^/]+/[^/]+ ]]; then
              echo "$dir" | sed 's|^./\([^/]\+\)/\([^/]\+\)|\1-\2|' | tr '[:upper:]' '[:lower:]'
            fi
          done | sort -u)

          # Now extract FROM directives and filter against our valid images
          BUILD_CONTEXTS=$(grep -h "^FROM.*\${.*_IMAGE}" ./${{ matrix.image_path }}/Dockerfile | while read -r line; do
            # Extract variable name from FROM line
            var_name=$(echo "$line" | grep -o '\${[^}]*}' | tr -d '${}\n')
            # Extract image name and remove any default tag
            image=$(grep "^ARG ${var_name}=" ./${{ matrix.image_path }}/Dockerfile | cut -d'=' -f2 | cut -d':' -f1)
            # Check if this image is in our valid image list
            if echo "$VALID_IMAGES" | grep -q "^${image}$"; then
              # Use short name for context key but specify it as a docker-image context with SHA tag
              echo "${image}=docker-image://ghcr.io/blockjoy/${image}:${{ steps.version.outputs.sha }}"
            fi
          done | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "contexts=${BUILD_CONTEXTS}" >> $GITHUB_OUTPUT
          echo "Generated build contexts: ${BUILD_CONTEXTS}"
          echo "Valid images: ${VALID_IMAGES}"
          echo "Current image path: '${{ matrix.image_path }}'"
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@6524bf65af31da8d45b59e8c27de4bd072b392f5 # v3
        with:
          buildkitd-flags: |
            --debug
            --allow-insecure-entitlement network.host
      - name: Build and push client images
        uses: docker/build-push-action@b32b51a8eda65d6793cd0494a773d4f6bcef32dc # v6
        with:
          context: ./${{ matrix.image_path }}
          push: true
          build-args: |
            GRAFANA_LOKI_BASICAUTH=${{ secrets.GRAFANA_LOKI_BASICAUTH }}
            GRAFANA_PROM_BASICAUTH=${{ secrets.GRAFANA_PROM_BASICAUTH }}
            CLOUDFLARE_API_KEY=${{ secrets.CLOUDFLARE_API_KEY }}
          build-contexts: ${{ steps.build-contexts.outputs.contexts }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: |
            ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:${{ steps.version.outputs.image_tag }}
            ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:${{ steps.version.outputs.version_tag }}

  build-protocols:
    needs: [detect-changes]
    if: |
      github.event_name == 'pull_request' && 
      github.event.pull_request.user.login != 'renovate[bot]' && 
      github.event.action != 'closed' &&
      fromJson(needs.detect-changes.outputs.protocols_matrix).include[0] != null
    runs-on: dev
    permissions:
      contents: read      # Allows reading repository contents
      packages: write     # Allows pushing/pulling container images
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.protocols_matrix) }}
    outputs:
      matrix: ${{ needs.detect-changes.outputs.protocols_matrix }}
      version_changed: ${{ steps.check-version.outputs.version_changed }}
      previous_version: ${{ steps.check-version.outputs.previous_version }}
      current_version: ${{ steps.check-version.outputs.current_version }}
      image_name: ${{ steps.version.outputs.image_name }}
      image_tag: ${{ steps.version.outputs.image_tag }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Generate version
        id: version
        run: |
          set -x  # Enable debug mode to see commands being executed
          set +e
          SHA=$(git rev-parse --short HEAD)
          DATE=$(date '+%Y%m%d')
          PROTOCOL_PATH=${{ matrix.image_path }}
          # Extract just the protocol name without the parent directory
          PROTOCOL=$(echo "${{ matrix.image_path }}" | cut -d'/' -f2)
          IMAGE_NAME=$(echo "${{ matrix.image_path }}" | cut -d'/' -f3)
          
          echo "Debug: matrix.image_path = ${{ matrix.image_path }}"
          echo "Debug: IMAGE_NAME = ${IMAGE_NAME}"
          
          # Try to get the current build number, default to 0 if API call fails
          echo "Debug: Querying GitHub API for package ${IMAGE_NAME}"
          
          OUTPUT=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/blockjoy/packages/container/${IMAGE_NAME}/versions" 2>&1)
          API_STATUS=$?
          
          echo "Debug: Full command output:"
          echo "$OUTPUT"
          echo "Debug: API Status: $API_STATUS"
          echo "Debug: Checking if output contains error message..."
          
          # More detailed error checking
          if echo "$OUTPUT" | grep -q "message.*Package not found" || \
             echo "$OUTPUT" | grep -q "status.*404" || \
             [ $API_STATUS -ne 0 ]; then
            echo "Package not found or API error detected"
            echo "Setting build number to 1"
            BUILD_NUM=1
          else
            echo "API call succeeded, parsing response"
            LATEST_BUILD=$(echo "$OUTPUT" | \
              jq "[.[] | select(.metadata.container.tags[] | startswith(\"v${DATE}\"))] | length")
            if [ -z "$LATEST_BUILD" ] || [ "$LATEST_BUILD" = "null" ]; then
              echo "No existing versions found for today, starting at 1"
              BUILD_NUM=1
            else
              echo "Found $LATEST_BUILD existing versions today"
              BUILD_NUM=$((LATEST_BUILD + 1))
            fi
          fi
          
          echo "Debug: Final build number: ${BUILD_NUM}"
          
          # Format: v20250108.1, v20250108.2, etc
          VERSION_TAG="v${DATE}.${BUILD_NUM}"
          
          echo "Debug: Version tag: ${VERSION_TAG}"
          
          # Make sure we have a build number before continuing
          if [ -z "$BUILD_NUM" ]; then
            echo "Error: Build number is empty, defaulting to 1"
            BUILD_NUM=1
            VERSION_TAG="v${DATE}.${BUILD_NUM}"
          fi
          
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${SHA}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          
          # Script should succeed even if API call failed
          exit 0
      - name: Generate build contexts
        id: build-contexts
        run: |
          # First, find all directories containing Dockerfiles to build our valid image list
          VALID_IMAGES=$(find . -name Dockerfile -exec dirname {} \; | while read dir; do
            # Convert directory path to image name (e.g., ./ethereum/ethereum-erigon -> ethereum-erigon)
            basename "$dir" | tr '[:upper:]' '[:lower:]'
            # For protocol directories, also add the protocol-client format
            if [[ "$dir" =~ ^./[^/]+/[^/]+ ]]; then
              echo "$dir" | sed 's|^./\([^/]\+\)/\([^/]\+\)|\1-\2|' | tr '[:upper:]' '[:lower:]'
            fi
          done | sort -u)

          # Now extract FROM directives and filter against our valid images
          BUILD_CONTEXTS=$(grep -h "^FROM.*\${.*_IMAGE}" ./${{ matrix.image_path }}/Dockerfile | while read -r line; do
            # Extract variable name from FROM line
            var_name=$(echo "$line" | grep -o '\${[^}]*}' | tr -d '${}\n')
            # Extract image name and remove any default tag
            image=$(grep "^ARG ${var_name}=" ./${{ matrix.image_path }}/Dockerfile | cut -d'=' -f2 | cut -d':' -f1)
            # Check if this image is in our valid image list
            if echo "$VALID_IMAGES" | grep -q "^${image}$"; then
              # Use short name for context key but specify it as a docker-image context with SHA tag
              echo "${image}=docker-image://ghcr.io/blockjoy/${image}:${{ steps.version.outputs.sha }}"
            fi
          done | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "contexts=${BUILD_CONTEXTS}" >> $GITHUB_OUTPUT
          echo "Generated build contexts: ${BUILD_CONTEXTS}"
          echo "Valid images: ${VALID_IMAGES}"
          echo "Current image path: '${{ matrix.image_path }}'"
      - name: Generate build args
        id: build-args
        run: |
          # Extract all *_IMAGE args from Dockerfile with their specified tags
          IMAGE_ARGS=$(grep "^ARG.*_IMAGE=" ./${{ matrix.image_path }}/Dockerfile | while read -r line; do
            var_name=$(echo "$line" | cut -d'=' -f1 | cut -d' ' -f2)
            # Use the full image reference from the Dockerfile, including its tag
            image_ref=$(echo "$line" | cut -d'=' -f2)
            echo "${var_name}=${image_ref}"
          done | tr '\n' '\n')
          echo "image_args<<EOF" >> $GITHUB_OUTPUT
          echo "$IMAGE_ARGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@6524bf65af31da8d45b59e8c27de4bd072b392f5 # v3
        with:
          buildkitd-flags: |
            --debug
            --allow-insecure-entitlement network.host
      - name: Build and push protocol images
        uses: docker/build-push-action@b32b51a8eda65d6793cd0494a773d4f6bcef32dc # v6
        with:
          context: ./${{ matrix.image_path }}
          push: true
          build-args: |
            GRAFANA_LOKI_BASICAUTH=${{ secrets.GRAFANA_LOKI_BASICAUTH }}
            GRAFANA_PROM_BASICAUTH=${{ secrets.GRAFANA_PROM_BASICAUTH }}
            CLOUDFLARE_API_KEY=${{ secrets.CLOUDFLARE_API_KEY }}
            ${{ steps.build-args.outputs.image_args }}
          build-contexts: ${{ steps.build-contexts.outputs.contexts }}
          cache-from: |
            type=registry,ref=ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:buildcache
          cache-to: |
            type=registry,ref=ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:buildcache,mode=max
          platforms: linux/amd64
          tags: |
            ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:${{ steps.version.outputs.image_tag }}
            ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:${{ steps.version.outputs.version_tag }}

      - name: Check version change
        id: check-version
        run: |
          # Get the current version from babel.yaml
          CURRENT_VERSION=$(yq e '.version' ${{ matrix.image_path }}/babel.yaml)
          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          
          # Get the version from the base branch
          PREVIOUS_VERSION=$(git show origin/main:${{ matrix.image_path }}/babel.yaml | yq e '.version' -)
          echo "previous_version=${PREVIOUS_VERSION}" >> $GITHUB_OUTPUT
          
          # Check if version has changed
          if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "Version changed from ${PREVIOUS_VERSION} to ${CURRENT_VERSION}"
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT
            echo "Version unchanged: ${CURRENT_VERSION}"
          fi

      - name: Get variants from babel.yaml
        id: get-variants
        run: |
          variants=$(yq e '.variants[].key' ${{ matrix.image_path }}/babel.yaml | tr '\n' ' ')
          if [ -z "$variants" ]; then
            echo "❌ No variants found in ${{ matrix.image_path }}/babel.yaml"
            exit 1
          fi
            echo "variants=$variants" >> $GITHUB_OUTPUT

      - name: Check variants
        id: check-variants
        run: |
          # Copy babel.yaml to test file
          cp ${{ matrix.image_path }}/babel.yaml ${{ matrix.image_path }}/babel.yaml-test
          
          # Update container_uri with newly built image
          NEW_URI="docker://ghcr.io/blockjoy/${{ steps.version.outputs.image_name }}:${{ steps.version.outputs.image_tag }}"
          yq -i e ".container_uri = \"$NEW_URI\"" ${{ matrix.image_path }}/babel.yaml-test

          echo "test_file=${{ matrix.image_path }}/babel.yaml-test" >> $GITHUB_OUTPUT

          success_variants=()
          failed_variants=()
          for variant in ${{ steps.get-variants.outputs.variants }}; do
            echo "Checking variant: $variant"
            
            # Run nib image check and capture output
            if nib image check --variant $variant --path ${{ matrix.image_path }}/babel.yaml-test; then
              success_variants+=("$variant")
              echo "✅ Variant $variant check passed"
            else
              echo "❌ Variant $variant check failed"
              failed_variants+=("$variant")
            fi
          done
          
          rm -rf ${{ matrix.image_path }}/babel.yaml-test
          
          if [ ${#failed_variants[@]} -gt 0 ]; then
            echo "❌ The following variants failed checks: ${failed_variants[*]}"
            exit 1
          fi
          
          echo "success_variants=${success_variants[*]}" >> $GITHUB_OUTPUT

  get-host:
    needs: [build-protocols]
    if: |
      github.event.pull_request.user.login != 'renovate[bot]' && 
      (github.event.pull_request.merged == true || 
       github.event.action == 'closed' || 
      github.event.action == 'opened' ||
       github.event.action == 'synchronize')
    runs-on: dev
    outputs:
      target_host: ${{ steps.get-host.outputs.target_host }}
    steps:
      - name: Get previous host
        id: get-host
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PREV_HOST=$(gh pr view ${{ github.event.pull_request.number }} --json comments --jq '
            .comments
            | map(select(.author.login == "github-actions"))
            | map(select(.body | contains("following nodes have been deployed")))
            | sort_by(.createdAt)
            | last
            | if . == null then "" else
              (.body | capture("The following nodes have been deployed on `(?<host>[^`]+)`:\\n").host)
              end
          ')
          if [ -z "$PREV_HOST" ]; then
            echo "No previous host found, using default"
            PREV_HOST="dev"
          else
            echo "Found previous host: $PREV_HOST"
          fi
          echo "target_host=$PREV_HOST" >> $GITHUB_OUTPUT

  test-nodes:
    needs: [build-protocols, get-host]
    if: |
      github.event_name == 'pull_request' && 
      github.event.pull_request.user.login != 'renovate[bot]' && 
      github.event.action != 'closed' ||
      contains(github.event.pull_request.labels.*.name, 'tests-fail')
    strategy:
      matrix: ${{ fromJson(needs.build-protocols.outputs.matrix) }}
    outputs:
      runner_host: ${{ steps.test-nodes.outputs.runner_host }}
      node_names: ${{ steps.test-nodes.outputs.node_names }}
    runs-on: ${{ needs.get-host.outputs.target_host }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
      - name: Create test babel file
        run: |
          # Copy babel.yaml to test file
          cp ${{ matrix.image_path }}/babel.yaml ${{ matrix.image_path }}/babel.yaml-test
          
          # Update container_uri with newly built image
          NEW_URI="docker://ghcr.io/blockjoy/${{ needs.build-protocols.outputs.image_name }}:${{ needs.build-protocols.outputs.image_tag }}"
          yq -i e ".container_uri = \"$NEW_URI\"" ${{ matrix.image_path }}/babel.yaml-test

      - name: Test nodes
        id: test-nodes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Store runner hostname
          RUNNER_HOST=$(hostname)
          echo "runner_host=${RUNNER_HOST}" >> $GITHUB_OUTPUT
          
          # Get variants from babel.yaml
          VARIANTS=$(yq e '.variants[].key' ${{ matrix.image_path }}/babel.yaml-test)
          if [ $? -ne 0 ]; then
            echo "Error: Failed to get variants from babel.yaml"
            echo "Content of babel.yaml-test:"
            cat ${{ matrix.image_path }}/babel.yaml-test
            exit 1
          fi
          
          # Initialize arrays for node info
          declare -a NODE_NAMES=()
          declare -a DEPLOYED_NODES=()
          START_FAILED=false
          
          # For each variant, start a node and capture info
          for variant in $VARIANTS; do
            echo "Testing variant: $variant"
            
            # Run nib image play and capture output
            echo "Running: nib image play --variant $variant --path ${{ matrix.image_path }}/babel.yaml-test"
            OUTPUT=$(nib image play --variant $variant --path ${{ matrix.image_path }}/babel.yaml-test 2>&1 || true)
            NIB_EXIT=$?
            echo "nib image play output:"
            echo "$OUTPUT"
            if [ $NIB_EXIT -ne 0 ]; then
              echo "Error: nib image play failed with exit code $NIB_EXIT"
              exit 1
            fi
            
            # Extract node name using sed
            NODE_NAME=$(echo "$OUTPUT" | grep -o 'name: "[^"]*"' | head -1 | cut -d'"' -f2)
            if [ -z "$NODE_NAME" ]; then
              echo "Error: Failed to extract node name from output"
              exit 1
            fi
            
            # Store for later use
            NODE_NAMES+=("$NODE_NAME")
            
            # Add to deployed nodes list before attempting start
            DEPLOYED_NODES+=("- \`${NODE_NAME}\`, running variant \`${variant}\`")
            
            # Start the node
            echo "Starting node ${NODE_NAME}"
            if ! START_OUTPUT=$(bv n start "$NODE_NAME" 2>&1); then
              echo "Error: Failed to start node ${NODE_NAME}:"
              echo "$START_OUTPUT"
              # Post comment about deployed nodes before failing
              if [ ${#DEPLOYED_NODES[@]} -gt 0 ]; then
                COMMENT="The following nodes have been deployed on \`${RUNNER_HOST}\`:"$'\n'
                for node in "${DEPLOYED_NODES[@]}"; do
                  COMMENT="${COMMENT}${node}"$'\n'
                done
                COMMENT="${COMMENT}"$'\n'"These nodes will be cleaned up on PR merge or close and replaced on PR update."
                echo -e "$COMMENT" | gh pr comment ${{ github.event.pull_request.number }} --body-file -
              fi
              exit 1
            fi
            echo "Successfully started node ${NODE_NAME}"
          done

          # Save node names for cleanup
          echo "node_names=${NODE_NAMES[*]}" >> $GITHUB_OUTPUT
          echo "start_failed=${START_FAILED}" >> $GITHUB_OUTPUT

  nib-image-push:
    needs: [test-nodes, build-protocols]
    if: |
      github.event.pull_request.merged == true && 
      github.event.action != 'closed'
    runs-on: dev
    permissions:
      contents: read      # Allows reading repository contents
      packages: write     # Allows pushing/pulling container images
    strategy:
      matrix: ${{ fromJson(needs.build-protocols.outputs.matrix) }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      - name: Check protocol key in protocols.yaml
        id: check-protocol
        run: |
          # Get protocol key from babel.yaml
          PROTOCOL_KEY=$(yq e '.protocol_key' ${{ matrix.image_path }}/babel.yaml)
          echo "Checking for protocol key: $PROTOCOL_KEY"
          
          # Check if key exists in protocols.yaml
          if ! yq e '.[] | select(.key == "'$PROTOCOL_KEY'")' protocols/protocols.yaml > /dev/null 2>&1; then
            echo "❌ Protocol key '$PROTOCOL_KEY' not found in protocols/protocols.yaml"
            exit 1
          fi
          
          # Check if protocols.yaml has changed
          if git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep -q "^protocols/protocols.yaml$"; then
            echo "protocols/protocols.yaml has changed, will push protocol updates"
            echo "protocols_changed=true" >> $GITHUB_OUTPUT
          else
            echo "protocols/protocols.yaml unchanged"
            echo "protocols_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Push protocol updates
        if: steps.check-protocol.outputs.protocols_changed == 'true'
        run: |
          echo "Pushing protocol updates"
          nib protocol push --path protocols/protocols.yaml

      - name: Push image to nib
        if: needs.build-protocols.outputs.version_changed == 'true'
        run: |
          echo "Pushing image (version changed from ${{ needs.build-protocols.outputs.previous_version }} to ${{ needs.build-protocols.outputs.current_version }})"
          nib image push --path ${{ matrix.image_path }}/babel.yaml

  cleanup:
    needs: [get-host]
    if: |
      github.event.pull_request.user.login != 'renovate[bot]' && 
      ((github.event.pull_request.merged == true || 
       github.event.action == 'closed' || 
       github.event.action == 'synchronize') &&
       github.event.action != 'opened')
    runs-on: ${{ needs.get-host.outputs.target_host }}
    steps:
      - name: Cleanup nodes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Finding nodes to clean up..."
          NODES=$(gh pr view ${{ github.event.pull_request.number }} --json comments --jq '
            .comments
            | map(select(.author.login == "github-actions"))
            | map(select(.body | contains("following nodes have been deployed")))
            | sort_by(.createdAt)
            | last
            | if . == null then "" else
              (.body | split("\n") 
              | map(select(contains("running variant"))) 
              | map(capture("- `(?<n>[a-z-]+-[a-z-]+-[a-z-]+)`, running variant `[^`]+`").n)
              | join("\n"))
              end
          ')
          
          if [ ! -z "$NODES" ]; then
            echo "Found nodes to clean up:"
            echo "$NODES" | while read -r node; do
              if [ -z "$node" ]; then 
                echo "Skipping empty node name"
                continue
              fi
              echo "Processing node: '$node'"
              bv n delete -y "$node" || echo "Warning: Failed to delete node '$node'"
            done
            
            # Post appropriate message based on trigger
            if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
              gh pr comment ${{ github.event.pull_request.number }} --body " All nodes have been cleaned up after merge"
            elif [[ "${{ github.event.action }}" == "closed" ]]; then
              gh pr comment ${{ github.event.pull_request.number }} --body " All nodes have been cleaned up after PR close"
            elif [[ "${{ github.event.action }}" == "synchronize" ]]; then
              gh pr comment ${{ github.event.pull_request.number }} --body " All nodes have been cleaned up after PR update"
            else
              gh pr comment ${{ github.event.pull_request.number }} --body " All nodes have been cleaned up"
            fi
          fi

  workflow-status:
    needs: [detect-changes, build-base, build-clients, build-protocols, test-nodes]
    if: always()
    runs-on: self-hosted
    steps:
      - name: Check workflow status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # First check if tests-fail label exists
          if gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name' | grep -q "tests-fail"; then
            echo "❌ Tests failed (tests-fail label present)"
            exit 1
          fi
          echo "Job results:"
          echo "detect-changes: ${{ needs.detect-changes.result }}"
          echo "build-base: ${{ needs.build-base.result }}"
          echo "build-clients: ${{ needs.build-clients.result }}"
          echo "build-protocols: ${{ needs.build-protocols.result }}"
          echo "test-nodes: ${{ needs.test-nodes.result }}"
          
          # If builds were skipped or only detect-changes ran, that means no relevant files changed
          if [[ "${{ needs.build-base.result }}" == "skipped" ]] && \
             [[ "${{ needs.build-clients.result }}" == "skipped" ]] && \
             [[ "${{ needs.build-protocols.result }}" == "skipped" ]] && \
             [[ "${{ needs.test-nodes.result }}" == "skipped" ]]; then
            echo "No relevant files changed - marking as success"
            exit 0
          fi
          
          # Otherwise check if any non-skipped jobs failed
          if [[ "${{ needs.build-base.result }}" != "skipped" && "${{ needs.build-base.result }}" != "success" ]] || \
             [[ "${{ needs.build-clients.result }}" != "skipped" && "${{ needs.build-clients.result }}" != "success" ]] || \
             [[ "${{ needs.build-protocols.result }}" != "skipped" && "${{ needs.build-protocols.result }}" != "success" ]] || \
             [[ "${{ needs.test-nodes.result }}" != "skipped" && "${{ needs.test-nodes.result }}" != "success" ]]; then
            echo "One or more builds failed"
            gh pr edit ${{ github.event.pull_request.number }} --add-label "tests-fail"
            exit 1
          fi
          
          echo "All triggered builds completed successfully"
          exit 0
